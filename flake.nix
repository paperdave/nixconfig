# Nix flakes are an experimental, but widely adopted way of writing Nix projects.
# https://nixos.wiki/wiki/Flakes
{
  inputs = {
    # sort-lines: start
    blender-bin.inputs.nixpkgs.follows = "nixpkgs";
    blender-bin.url = "github:edolstra/nix-warez?dir=blender";
    flake-utils.url = "github:numtide/flake-utils";
    home-manager.inputs.nixpkgs.follows = "nixpkgs";
    home-manager.url = "github:nix-community/home-manager/release-24.05";
    nixpkgs.url = "nixpkgs/nixos-24.05";
    stylix.inputs.nixpkgs.follows = "nixpkgs";
    stylix.url = "github:danth/stylix";
    # sort-lines: end
  };
  outputs =
    { self
    , flake-utils
    , home-manager
    , nixpkgs
    , ...
    } @ inputs:
    let
      inherit (nixpkgs) lib;
      utils = flake-utils.lib;

      # System configurations are done purely via hostname, then specified here.
      #
      # Each configuration is prepared using two configuration files:
      #   ./systems/{hostname}.nix - Handwritten config for users, services, etc...
      #   ./systems/{hostname}.hardware.nix - Generated by `nixos-generate-config`
      #
      # These will combine alongside ./configuration.nix to form the full system.
      systems = [ "zenith" ];

      # Users define home manager presets, but these currently all share the
      # same, shared config: ./home.nix
      users = {
        dave = {
          name = "Dave Caruso"; # name/identifier
          email = "me@paperdave.net"; # email (used for certain configurations)
          config = "code/config";
        };
      };

      mkNixpkgs = system: import nixpkgs {
        inherit system;
        config = {
          # there are dependencies on unfree software, as well as paid software
          allowUnfree = true;
          allowUnfreePredicate = _: true == true;
          # we are a NVIDIA household, for better or for worse
          cudaSupport = true;
        };
        overlays = [ ];
      };

      withPkgs = f: system: f (mkNixpkgs system);

      mkSystemConfiguration =
        { hostname
        , userConfig
        , genConfig
        , system
        }: lib.nixosSystem {
          modules = [ ./configuration.nix userConfig genConfig ];
          specialArgs = {
            inherit hostname inputs;
            pkgs = mkNixpkgs system;
          };
        };

      mkHomeConfiguration =
        { username
        , pkgs
        , name ? null
        , email ? null
        , config
        }: home-manager.lib.homeManagerConfiguration {
          inherit pkgs;
          modules = [ ./home.nix ];
          extraSpecialArgs = {
            inherit inputs;
            user = { inherit username name email config; };
          };
        };
    in
    builtins.foldl' lib.recursiveUpdate { } [
      { lib = { inherit mkSystemConfiguration; }; }

      (utils.eachDefaultSystem (withPkgs (pkgs: {
        formatter = pkgs.nixpkgs-fmt;
      })))

      # Fusion is currently only set up for x86_64-linux
      (utils.eachSystem [ "x86_64-linux" ] (withPkgs (pkgs: {
        packages.fusion-studio = pkgs.callPackage ./packages/fusion-studio.nix { };
      })))

      # This merges `systems` into a set of NixOS Configurations
      {
        nixosConfigurations = builtins.listToAttrs (builtins.map
          (hostname:
            let
              userConfig = "${./systems}/${hostname}.nix";
              genConfig = "${./systems}/${hostname}.hardware.nix";

              # I attempted to use `evalModules`, but a lack of skill prevented this
              # We will assume the generated file is always the same format.
              system = (import genConfig {
                config = builtins.throw "unexpected";
                pkgs = builtins.throw "unexpected";
                modulesPath = builtins.throw "unexpected";
                lib.mkDefault = x: x;
              }).nixpkgs.hostPlatform;
            in
            {
              name = hostname;
              value = mkSystemConfiguration {
                inherit hostname userConfig genConfig system;
              };
            })
          systems);
      }

      # This merges `users` into a set of home-manager configurations
      # Use a dummy derivation to allow placing home configurations per-user+system
      (utils.eachDefaultSystem (withPkgs (pkgs: {
        packages.homeConfigurations = derivation { name = "home-configurations"; }
          // (lib.mapAttrs
          (username: user: mkHomeConfiguration (user // { inherit username pkgs; }))
          users);
      })))
    ];

}

